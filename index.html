<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link rel="stylesheet" href="css/style.css">
</head>
<body>
  <div class="region">
    <div class="stage">
      <div class="data-panel">
        <div class="data-filter" id="data_filter">
          <div class="data-filter__group">
            <p><b>Manufacturer:</b></p>
            <select class="filter-item" v-model="selected.manufacturer" @change="handleValidatorChange('manufacturer')">
              <option value="">-Select-</option>
              <option v-for="v in groups.manufacturer.all()" :key="v.id" :value="v.id">{{ v.value+' ('+v.total+')' }}</option>
            </select>
          </div>
          <div class="data-filter__group">
            <p><b>Category:</b></p>
            <div class="data-filter__validator" v-for="v in groups.category.all()">
              <input type="checkbox" v-model="selected.category" :value="v.id" :id="v.id" @change="handleValidatorChange('category')">
              <label :for="v.id">{{ v.value }}</label>
            </div>
          </div>
          <div class="data-filter__group">
            <p><b>Search:</b></p>
            <input type="text" placeholder="Search..." v-model="keywords.search" @input="handleFilterChange">
          </div>
        </div>
        <div class="data-layout data-layout--table" id="data_layout">
          <div class="table-wrapper">
            <table class="jc-table">
              <thead>
                <tr>
                  <th @click.stop="sortBy" data-prop="manufacturer"><span class="data-layout__table-header">Manufacturer<i class="sort-indicator"></i></span></th>
                  <th @click.stop="sortBy" data-prop="manufacture_oe"><span class="data-layout__table-header">Manufacturer #<i class="sort-indicator"></i></span></th>
                  <th @click.stop="sortBy" data-prop="inborn_filter_oe"><span class="data-layout__table-header">Inborn Filter #<i class="sort-indicator"></i></span></th>
                  <th @click.stop="sortBy" data-prop="category"><span class="data-layout__table-header">Category<i class="sort-indicator"></i></span></th>
                </tr>
              </thead>
              <tbody>
                <tr v-for="record in currentPageRecords">
                  <td>{{ record.manufacturer }}</td>
                  <td>{{ record.manufacture_oe }}</td>
                  <td>{{ record.inborn_filter_oe }}</td>
                  <td>{{ record.category }}</td>
                </tr>
              </tbody>
            </table>
          </div>
          <el-pagination
            background
            layout="prev, pager, next"
            :total="records.length"
            :page-size="pagination.perPage"
            @current-change="handleCurrentPageChange">
          </el-pagination>
        </div>
      </div>
    </div>
  </div>

  <script src="./js/vendor/underscore.min.js"></script>
  <script src="./js/vendor/axios/dist/axios.min.js"></script>
  <script src="./js/vendor/vue/dist/vue.min.js"></script>
  <script src="./js/vendor/element/lib/index.js"></script>
  <script src="./js/utils.js"></script>
  <script src="./js/validators.js"></script>
  <script src="./js/records.js"></script>
  <script>
    /**
     * 生成数据展示组件
     */
    const dataLayout = (function() {

      // 目标元素
      const el = '#data_layout';

      // 数据默认按那一列排序
      const defaultOrder = 'manufacturer';

      // 排序指示器（图标）的选择器
      const sortIndicatorSelector = '.sort-indicator';

      // 升序时排序指示器添加的类
      const descendingClass = 'descending';

      // 降序时排序指示器添加的类
      const ascendingClass = 'ascending';

      return new Vue({
        el: el,

        data: function() {
          return {
            records: [],
            pagination: {
              perPage: 15,
              currentPage: 1,
            },
            sort: {},
          };
        },

        computed: {
          // 当前页分展示的记录
          currentPageRecords: function() {
            const perpage = this.pagination.perPage;
            const page = this.pagination.currentPage;
            return this.records.slice((page-1)*perpage, page*perpage);
          },
        },

        methods: {
          // 初始化
          init: function(records) {
            this.resetSortIndicator();
            if (defaultOrder) {
              records = _.sortBy(records, defaultOrder);
            }
            this.$set(this.$data, 'records', records.slice());
            this.pagination.currentPage = 1;
            this.sort.original = records.slice();
          },

          // 排序
          sortBy: function(event) {

            const sort = this.sort;
            const target = event.currentTarget;
            const column = target.getAttribute('data-prop');
            const indicator = target.querySelector(sortIndicatorSelector);
            const indicatorClass = indicator.classList;

            if (sort.current !== column) {
              this.resetSortIndicator();
            }
            sort.current = column;
            sort.indicator = indicator;

            // 如果未排序，则升序
            if (! sort[column]) {
              sort[column] = 'asc';
              this.$set(this.$data, 'records', _.sortBy(this.records, column));
              indicatorClass.remove(descendingClass);
              indicatorClass.add(ascendingClass);
            }

            // 如果升序，则降序
            else if (sort[column] === 'asc') {
              sort[column] = 'desc';
              this.records.reverse();
              indicatorClass.remove(ascendingClass);
              indicatorClass.add(descendingClass);
            }

            // 如果降序，则恢复未排序状态
            else if (sort[column] === 'desc') {
              this.resetSortIndicator();
              if (sort.original) {
                this.$set(this.$data, 'records', sort.original.slice());
              }
            }
          },

          // 清除排序标记
          resetSortIndicator: function() {
            const sort = this.sort;

            if (sort.indicator) {
              sort.indicator.classList.remove(ascendingClass);
              sort.indicator.classList.remove(descendingClass);
            }
            if (sort.current) {
              sort[sort.current] = null;
              sort.current = null;
            }
          },

          // 当前页改变
          handleCurrentPageChange: function(page) {
            this.pagination.currentPage = page;
          },
        },
      });
    })();

    /**
     * 生成数据筛选组件
     */
    const dataFilter = (function(dataLayoutComponent) {

      // 目标元素
      const el = '#data_filter';

      const groupsSchema = [
        { // 定义在属性 manufacturer 上的值验证器组
          name: 'manufacturer',
          type: 'value',
          prop: 'manufacturer',
          multiple: false,
        },
        { // 定义在属性 category 上的值验证器组
          name: 'category',
          type: 'value',
          prop: 'category',
          multiple: true,
        },
        { // 定义在 'manufacturer', 'manufacture_oe' 和 'inborn_filter_oe' 三个属性上的检索验证器组
          name: 'search',
          type: 'contains',
          prop: ['manufacturer','manufacture_oe','inborn_filter_oe'],
          multiple: true,
          keywords: 'keywords.search',
        },
      ];

      return new Vue({
        el: el,

        data: function() {
          return {
            records: [],
            groups: {},
            selected: {
              manufacturer: '',
              category: [],
            },
            keywords: {
              search: '',
            },
          };
        },

        created: function() {
          this.generateGroups();

          this.$on('after-filter', function(data) {
            dataLayoutComponent.init(data);
          });

          const app = this;
          this.groups['search'].all().forEach(function(validator) {
            validator.setKeywordsResolver(function() {
              return app.keywords;
            });
            validator.activate();
          });
        },

        methods: {
          // 初始化
          init: function(data) {
            this.records = data.slice();
            this.generateGroups();
            this.reset();
          },

          // 生成验证器组
          generateGroups: function() {
            const records = this.records;
            const groups = {};
            const app = this;

            // 根据构造信息生成验证器组
            groupsSchema.forEach(function(schema) {
              schema.data = records;
              const group = ValidatorGroup.make(schema);
              groups[schema.name] = group;

              // 如果是检索验证器，则设置关键字获取器
              if (schema.type === 'contains') {
                const prop = schema.keywords || 'keywords.'+schema.name;
                group.all().forEach(function(validator) {
                  // 设置关键字获取器
                  validator.setKeywordsResolver(function() {
                    return prop.split('.').reduce(function(result, key) {
                      return result ? result[key] : '';
                    }, app.$data);
                  }).activate();
                });
              }
            });

            // 重设验证器组
            this.$set(this.$data, 'groups', groups);

            return this;
          },

          // 重置筛选器
          reset: function() {
            this.selected.manufacturer = '';
            this.selected.category = [];

            this.keywords.search = '';

            const groups = this.groups;
            groupsSchema.forEach(function(schema) {
              if (schema.type != 'contains') {
                groups[schema.name].all().forEach(function(validator) { validator.deactivate() });
              }
            });

            this.$emit('after-filter', this.records.slice());
          },

          // 可选的验证器改变时执行
          handleValidatorChange: function(group) {
            this.groups[group].activate(this.selected[group]);

            this.handleFilterChange();
          },

          // 筛选条件改变时重新筛选数据
          handleFilterChange: function() {
            const groups = [];
            for (const key in this.groups) {
              groups.push(this.groups[key]);
            }

            const records = this.records.filter(function(record) {
              for (let i = 0; i < groups.length; i++) {
                if (!groups[i].validate(record)) {
                  return false;
                }
              }
              return true;
            });

            this.$emit('after-filter', records);
          },
        },
      });
    })(dataLayout);

    dataFilter.init(records);
  </script>
</body>
</html>
